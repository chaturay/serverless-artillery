/* eslint-disable no-underscore-dangle */
const { TaskError } = require('./taskDef')

module.exports = run =>
  /**
   * Run a load test given an Artillery script and report the results
   * @param timeNow The time this task invocation began (serves as an id for the function)
   * @param script The artillery script to execution load from
   * @returns {Promise} Resolving to the load results report generated by Artillery
   */
  (timeNow, script) => {
    if (script._simulation) return Promise.resolve({ Payload: '{ "errors": 0 }' })

    return new Promise((resolve, reject) => {
      // Since Artillery will call process.exit() upon termination,
      // we monkey-patch it to load result and resolve/reject the Promise.
      const { exit } = process
      let testResults = null

      process.exit = (code) => {
        process.exit = exit // Unpatch
        console.log('Artillery done.')

        if (code !== 0) {
          reject(new TaskError(`Artillery exited with non-zero code: ${code}`))
        } else if (!testResults) {
          reject(new TaskError('Artillery exited with zero, but test results not set.'))
        } else {
          resolve(testResults)
        }
      }

      console.log('Starting Artillery...')
      run(script, { output: (result) => { testResults = result.aggregate } })
    })
      .catch((ex) => {
        const msg = `ERROR exception encountered while executing load from ${script._genesis} in ${timeNow}: ${ex.message}\n${ex.stack}`
        console.error(msg)
        throw new TaskError(msg)
      })
  }
