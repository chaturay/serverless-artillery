/* eslint-disable no-underscore-dangle */

const fs = require('fs')
const os = require('os')
const path = require('path')
const promisify = require('util-promisify')

const { TaskError } = require('./taskDef')

const readFile = promisify(fs.readFile)
const unlink = promisify(fs.unlink)

module.exports = run =>
  /**
   * Run a load test given an Artillery script and report the results
   * @param timeNow The time this task invocation began (serves as an id for the function)
   * @param script The artillery script to execution load from
   * @returns {Promise} Resolving to the load results report generated by Artillery
   */
  (timeNow, script) => {
    if (script._simulation) return Promise.resolve({ Payload: '{ "errors": 0 }' })

    const outputPath = path.resolve(os.tmpdir(), 'output.json')

    return new Promise((resolve, reject) => {
      // Since Artillery will call process.exit() upon termination,
      // we monkey-patch it to load result and resolve/reject the Promise.
      const exit = process.exit

      process.exit = (code) => {
        process.exit = exit // Unpatch
        console.log('Artillery done.')

        if (code === 0) {
          resolve()
        } else {
          reject(new TaskError(`Artillery exited with non-zero code: ${code}`))
        }
      }

      console.log('Starting Artillery...')
      run(script, { output: outputPath })
    })
      .then(() => readFile(outputPath, 'utf8'))
      .then(results => unlink(outputPath).then(() => JSON.parse(results)))
      .catch((ex) => {
        const msg = `ERROR exception encountered while executing load from ${script._genesis} in ${timeNow}: ${ex.message}\n${ex.stack}`
        console.error(msg)
        throw new TaskError(msg)
      })
}
